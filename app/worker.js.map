{
  "version": 3,
  "sources": ["worker.ts"],
  "sourcesContent": ["interface ServiceWorkerGlobalScope {\n  addEventListener(\n    name: string,\n    callback: (event: any) => void\n  ): void;\n}\n\ninterface FetchEvent {\n  waitUntil(\n    cb: () => Promise<any>\n  ): void;\n  respondWith(\n    arg0: Response | Promise<Response>\n  ): void;\n  request: RequestInfo & {\n    url: string;\n  };\n}\n\nclass WorkerActivator {\n  constructor(\n    private options: {\n      version: number;\n      cacheName: string;\n      databaseName: string;\n    }\n  ) {\n    this.upgradeDatabase();\n  }\n\n  private upgradeDatabase() {}\n}\n\nclass WorkerInstaller {\n  constructor(\n    private options: {\n      version: number;\n      cacheName: string;\n      databaseName: string;\n    }\n  ) {}\n}\n\nclass WorkerFetcher {\n  constructor(\n    private options: {\n      version: number;\n      cacheName: string;\n      databaseName: string;\n      update: boolean;\n    },\n    event: FetchEvent\n  ) {\n    if (\n      event.request.url.includes(\n        \"fauna.com\"\n      )\n    ) {\n      event.respondWith(\n        this.fetchFromServerOnly(event)\n      );\n    } else {\n      event.respondWith(\n        this.fetchFromCacheFirst(\n          this.options.cacheName,\n          event\n        )\n      );\n    }\n  }\n\n  /**\n   * Yes: Cache only\n   * Yes: Cache and update\n   * No: cache, update and refresh\n   * Yes: embedded fallback\n   * No: push and retrieve payload\n   * No: Push payload\n   * ...\n   * Yes: offline status\n   * Yes: offline fallback\n   * @param cacheName\n   * @param event\n   */\n  private fetchFromCacheFirst(\n    cacheName: string,\n    event: FetchEvent\n  ) {\n    const { update } = this.options;\n    const request = event.request;\n    const { url } = request;\n    console.log(url);\n\n    // ignore query strings\n    const hasQueryString =\n      0 < url.indexOf(\"?\");\n    const queryFreeUrl = !hasQueryString\n      ? url\n      : url.substring(\n          0,\n          url.indexOf(\"?\")\n        );\n\n    return <\n      Response | Promise<Response>\n    >(async () => {\n      const cache = await caches.open(\n        cacheName\n      );\n      let response = await cache.match(\n        queryFreeUrl\n      );\n      if (response) {\n        if (update)\n          fetch(event.request).then(\n            (response) => {\n              cache.put(\n                event.request,\n                response\n              );\n            }\n          );\n      } else {\n        response = await fetch(request);\n        cache.put(\n          queryFreeUrl,\n          response.clone()\n        );\n      }\n      return response;\n    })();\n  }\n\n  private fetchFromServerOnly(\n    event: FetchEvent\n  ) {\n    const request = event.request;\n    return fetch(request);\n  }\n}\n\nclass OfflineWorker {\n  constructor(private options: {}) {}\n\n  async runEvent(event: any) {\n    switch (event.tag) {\n      case \"offline\":\n        console.log(\n          \"offline event running\"\n        );\n    }\n    throw `unknown event name: ${event.tag}`;\n  }\n}\n\nclass AppServiceWorker {\n  constructor(\n    private options: {\n      version: number;\n      cacheName: string;\n      databaseName: string;\n      update: boolean;\n    }\n  ) {\n    const worker =\n      self as any as ServiceWorkerGlobalScope;\n\n    worker.addEventListener(\n      \"activate\",\n      () => {\n        new WorkerActivator(\n          this.options\n        );\n      }\n    );\n\n    worker.addEventListener(\n      \"install\",\n      (event: FetchEvent) => {\n        new WorkerInstaller(\n          this.options\n        );\n        event.waitUntil(async () => {\n          const cache =\n            await caches.open(\n              this.options.cacheName\n            );\n          await cache.addAll([\n            \"/app/index.html\",\n          ]);\n        });\n      }\n    );\n\n    worker.addEventListener(\n      \"fetch\",\n      (event: FetchEvent) => {\n        new WorkerFetcher(\n          this.options,\n          event\n        );\n      }\n    );\n\n    const offlineWorker =\n      new OfflineWorker({});\n\n    worker.addEventListener(\n      \"sync\",\n      (event: any) => {\n        console.log(\n          \"sync event handled\"\n        );\n        offlineWorker.runEvent(event);\n      }\n    );\n  }\n}\n\nfunction run() {\n  new AppServiceWorker({\n    version: 1,\n    cacheName: \"cache\",\n    databaseName: \"meta\",\n    update: false,\n  });\n}\n\nrun();\n"],
  "mappings": ";AAmBA,4BAAsB;AAAA,EACpB,YACU,SAKR;AALQ;AAMR,SAAK;AAAA;AAAA,EAGC,kBAAkB;AAAA;AAAA;AAG5B,4BAAsB;AAAA,EACpB,YACU,SAKR;AALQ;AAAA;AAAA;AAQZ,0BAAoB;AAAA,EAClB,YACU,SAMR,OACA;AAPQ;AAQR,QACE,MAAM,QAAQ,IAAI,SAChB,cAEF;AACA,YAAM,YACJ,KAAK,oBAAoB;AAAA,WAEtB;AACL,YAAM,YACJ,KAAK,oBACH,KAAK,QAAQ,WACb;AAAA;AAAA;AAAA,EAmBA,oBACN,WACA,OACA;AACA,UAAM,EAAE,WAAW,KAAK;AACxB,UAAM,UAAU,MAAM;AACtB,UAAM,EAAE,QAAQ;AAChB,YAAQ,IAAI;AAGZ,UAAM,iBACJ,IAAI,IAAI,QAAQ;AAClB,UAAM,eAAe,CAAC,iBAClB,MACA,IAAI,UACF,GACA,IAAI,QAAQ;AAGlB,WAEE,aAAY;AACZ,YAAM,QAAQ,MAAM,OAAO,KACzB;AAEF,UAAI,WAAW,MAAM,MAAM,MACzB;AAEF,UAAI,UAAU;AACZ,YAAI;AACF,gBAAM,MAAM,SAAS,KACnB,CAAC,cAAa;AACZ,kBAAM,IACJ,MAAM,SACN;AAAA;AAAA,aAIH;AACL,mBAAW,MAAM,MAAM;AACvB,cAAM,IACJ,cACA,SAAS;AAAA;AAGb,aAAO;AAAA;AAAA;AAAA,EAIH,oBACN,OACA;AACA,UAAM,UAAU,MAAM;AACtB,WAAO,MAAM;AAAA;AAAA;AAIjB,0BAAoB;AAAA,EAClB,YAAoB,SAAa;AAAb;AAAA;AAAA,QAEd,SAAS,OAAY;AACzB,YAAQ,MAAM;AAAA,WACP;AACH,gBAAQ,IACN;AAAA;AAGN,UAAM,uBAAuB,MAAM;AAAA;AAAA;AAIvC,6BAAuB;AAAA,EACrB,YACU,SAMR;AANQ;AAOR,UAAM,SACJ;AAEF,WAAO,iBACL,YACA,MAAM;AACJ,UAAI,gBACF,KAAK;AAAA;AAKX,WAAO,iBACL,WACA,CAAC,UAAsB;AACrB,UAAI,gBACF,KAAK;AAEP,YAAM,UAAU,YAAY;AAC1B,cAAM,QACJ,MAAM,OAAO,KACX,KAAK,QAAQ;AAEjB,cAAM,MAAM,OAAO;AAAA,UACjB;AAAA;AAAA;AAAA;AAMR,WAAO,iBACL,SACA,CAAC,UAAsB;AACrB,UAAI,cACF,KAAK,SACL;AAAA;AAKN,UAAM,gBACJ,IAAI,cAAc;AAEpB,WAAO,iBACL,QACA,CAAC,UAAe;AACd,cAAQ,IACN;AAEF,oBAAc,SAAS;AAAA;AAAA;AAAA;AAM/B,eAAe;AACb,MAAI,iBAAiB;AAAA,IACnB,SAAS;AAAA,IACT,WAAW;AAAA,IACX,cAAc;AAAA,IACd,QAAQ;AAAA;AAAA;AAIZ;",
  "names": []
}
